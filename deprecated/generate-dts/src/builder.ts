import type { Plugin, PluginRules } from './types'
import type { JSONSchema4 } from 'json-schema'
import { mkdir, rm, stat, writeFile } from 'node:fs/promises'
import { join } from 'node:path'
import { pascalCase } from 'change-case'
import { compile } from 'json-schema-to-typescript'
import { outdent } from 'outdent'
import { JsDocBuilder } from './jsdoc'

/**
 * If it doesn't exist, create the directory that will contain the plugin's rule files.
 */
export async function createPluginDirectory(
  pluginName: string,
  outDir: string,
): Promise<string> {
  const pluginDirectory: string = join(outDir, pluginName)
  const rulesDirectory: string = join(pluginDirectory, 'rules')

  const isExists = await stat(pluginDirectory).then(() => true).catch(() => false)
  if (isExists) await rm(pluginDirectory, { recursive: true, force: true })
  await mkdir(rulesDirectory, { recursive: true })

  return pluginDirectory
}

/**
 * Loads a plugin by importing its module and retrieving its rules.
 */
export async function loadPlugin(plugin: Plugin): Promise<Plugin> {
  const mod: any = await import(plugin.module)
  const rules: PluginRules
    = plugin.module === 'eslint'
      ? Object.fromEntries(new mod.Linter().getRules().entries())
      : mod.rules ?? mod.default.rules
  return { ...plugin, rules }
}

/**
 * Generate a `.d.ts` file for each rule in the given plugin.
 */
export async function generateRulesFiles(
  plugin: Plugin,
  pluginDirectory: string,
) {
  const { rules, module } = plugin
  if (!rules) {
    throw new Error(`Plugin ${module} doesn't have any rules.`)
  }

  const workspace = join(pluginDirectory, 'rules')

  for (const [ruleName, ruleOption] of Object.entries(rules)) {
    if (ruleName.includes('/')) continue
    const meta = ruleOption.meta!
    let schemas = (meta.schema as JSONSchema4[]) ?? []
    if (!Array.isArray(schemas)) schemas = [schemas]

    const options = await Promise.all(
      schemas.map(async (schema, index) => {
        let content = await compile(JSON.parse(
          JSON.stringify(schema).replaceAll('#/items/0/$defs/', '#/$defs/'),
        ), `Schema${index && index}`, {
          format: false,
          bannerComment: '',
          style: {
            singleQuote: true,
            trailingComma: 'all',
          },
          unknownAny: false,
        })
        content = cleanJsDoc(content)
        content = patchTypes(content)
        return content.replaceAll(/export\s+(type|interface)\s+/g, '$1 ')
      }).filter(Boolean),
    )
    const optionTypes = options
      .map((_, index) => `Schema${index}`)

    const ruleOptionTypeValue = Array.isArray(meta.schema)
      ? `[${optionTypes.join(', ')}]`
      : (meta.schema ? 'Schema0' : '[]')

    await writeFile(
      join(workspace, `${ruleName}.d.ts`),
      outdent`
        ${options.join('\n')}
        export type ${pascalCase(ruleName)}RuleOptions = ${ruleOptionTypeValue};
      `,
      { encoding: 'utf8', flag: 'w' },
    )
  }
}

/**
 * Generate the `index.d.ts` file for the plugin's rules that will re-export all rules.
 */
export async function generateRuleIndexFile(
  plugin: Plugin,
  pluginDirectory: string,
): Promise<void> {
  const { rules, module, name } = plugin
  if (!rules) {
    throw new Error(`Plugin ${module} doesn't have any rules. `)
  }

  const ruleOptionImports: string[] = []
  const ruleDeclarations: string[] = []

  for (const [ruleName, ruleOption] of Object.entries(rules)) {
    if (ruleName.includes('/')) continue
    const meta = ruleOption.meta!
    const docs = meta.docs ?? {}
    const description = docs.description?.replace(/\*\/`/g, '*\\/`')
    const deprecated = meta.deprecated

    ruleOptionImports.push(
      `import type { ${pascalCase(ruleName)}RuleOptions } from "./rules/${ruleName}"`,
    )

    ruleDeclarations.push(
      outdent`
        ${JsDocBuilder.build()
          .add(deprecated ? '@deprecated' : '')
          .add(deprecated ? ' ' : '')
          .add(description ?? '')
          .add(description ? ' ' : '')
          .add(`@see [${ruleName}](${docs.url})`)
          .output()
        }
        "${module === 'eslint' ? ruleName : `${name}/${ruleName}`}": ${pascalCase(ruleName)}RuleOptions; \n
      `)

    await writeFile(
      join(pluginDirectory, 'index.d.ts'),
      outdent`
        ${ruleOptionImports.join('\n')}

        export interface RuleOptions {
          ${ruleDeclarations.join('\n')}
        }
      `,
      { encoding: 'utf8', flag: 'w' },
    )
  }
}

/**
 * Remove unnecessary comments that are generated by `json-schema-to-typescript`.
 */
function cleanJsDoc(content: string): string {
  const patterns: RegExp[] = [
    /\* This interface was referenced by .+ JSON-Schema definition/,
    /\* via the `.+` "/,
  ]

  return content
    .split('\n')
    .filter(line => !patterns.some(ignoredLine => ignoredLine.test(line)))
    .join('\n')
}

/**
 * Replace some types that are generated by `json-schema-to-typescript`.
 */
export function patchTypes(content: string): string {
  const replacements: Array<{ pattern: RegExp, replacement: string }> = [
    {
      pattern:
        /\(string(?: & {\s*\[k: string]: any\s*}){2}\)\[]/,
      replacement: 'string[]',
    },
  ]
  let currentContent = content

  for (const { pattern, replacement } of replacements) {
    currentContent = content.replace(pattern, replacement)
  }

  return currentContent
}
